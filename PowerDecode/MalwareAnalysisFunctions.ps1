<#
Function name: GetObfuscationType
Description: Determines the obfuscation type of the obfuscated script received as input 
Function calls: IsCompressed, IsBase64, IsEncoded, Is,StringBased
Input: $ObfuscatedScript 
Output: (a string representing the obfuscation type)
#>

function GetObfuscationType() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )
	
  if( IsCompressed $ObfuscatedScript ) {
      return "Compressed"
   }
    
  if( IsBase64 $ObfuscatedScript ) {   
      return "Base64"   
  }
  
  if( IsEncoded $ObfuscatedScript ) { 
      return "Encoded"  
  }
        
  if( IsStringBased $ObfuscatedScript ) {    
      return "String-Based"
  }

  else {  
      return "Unknown" 
  }

   
}

<#
Function name: IsCompressed
Description: Returns true if the obfuscation type is compressed 
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false  
#>
function IsCompressed() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string ]$ObfuscatedScript
    )
	
#to lower conversion 
$lowerstring = $ObfuscatedScript.toLower() 




$DeflatePattern = [regex] "io\.compression\.deflatestream"
$GzipPattern = [regex] "io\.compression\.gzipstream"

$DeflateMatches = $DeflatePattern.matches($lowerstring)
$GzipMatches = $GzipPattern.matches($lowerstring)


if ($DeflateMatches.Count -gt 0){
     return $true 
     }
	 
if ($GzipMatches.Count -gt 0){
     return $true 
     } 


return $false 


}

<#
Function name: IsEncoded
Description: Returns true if the obfuscation type is encoded
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false   
#>
function IsEncoded() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )

$lowerstring = $ObfuscatedScript.toLower() 



#checking bxor
$pattern = [regex] "\-bxor"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     } 

#checking secure string
$pattern = [regex] "securestring"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }
#checking hex\oct\bin 
$pattern = [regex]  "\[convert\]\:\:toint16"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }


#remove spacelines 
$pattern = [regex]  " "
$matches = $pattern.Matches($lowerstring)

foreach  ($match in $matches) {

$ScriptNoSpacelines = $lowerstring.Replace( $match, '') 
}


#checking dec 
$pattern = [regex]  "\[int\]$_"
$matches = $pattern.Matches($ScriptNoSpacelines)
   if ($matches.Count -gt 0){
     return $true 
     }


return $false


}


<#
Function name: IsStringBased
Description: Returns true if the obfuscation type is string-based
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false
#>

function IsStringBased() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )



 $pattern = [regex] "(\{\d\}\'\s*-f)|(\'(.*?)\'\s*\+\s*\'(.*?)\')"
 $matches = $pattern.Matches($ObfuscatedScript) 

    if ($matches.Count -gt 0){
     return $true 
     }
     else {
      $lowerstring = $ObfuscatedScript.toLower() 
    
        
    $pattern = [regex] "\[char\]\d" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
    $pattern = [regex] "\'righttoleft\'" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
     return $false
     }
}



<#
Function name: ExtractUrls
Description: Receives a script as input and returns an array containing all urls detected  
Function calls: -
Input: $Script
Output: $Urls  
#>

function ExtractUrls() {
	param(
        [Parameter(Mandatory = $True)]  [string]$Script
    )
	
	
	$UrlPattern = [regex]  "(http[s]?|[s]?ftp[s]?)(:\/\/)(.*?)(\""|\'|\}|\@|\,|\s|\*)"
	
	$SplitPattern = [regex] "split\(\'\?\'\)"
	$SplitMatches = $SplitPattern.matches($Script)
	
	
	
	foreach ($match in $SplitMatches){
	  if ($match.success -eq $true ){
		  $UrlPattern = [regex]  "(http[s]?|[s]?ftp[s]?)(:\/\/)(.*?)(\""|\'|\}|\@|\,|\s|\*|\?)"
		  break; 
	  }
	
	}
	
	$Urls = @()
	$Url = ""

   
	
	$UrlMatches = $UrlPattern.matches($Script)
	
	Foreach($Group in $UrlMatches.Groups) {
		if($Group.Name -eq 0) {
			$Url = $Group.Value
			$Url = $Url.SubString(0, $Url.Length - 1)
			$Urls += $Url
		}
	}
		
	
	return $Urls
}
<#
Function name: UrlHttpResponseCheck
Description: Receives a url as input and returns the associated http response status code  
Function calls: -
Input: $Url
Output: $UrlInfo 
#>

function UrlHttpResponseCheck() {
	param([Parameter(Mandatory = $True)] [string]$Url
    )
	
	$HttpRequest = [System.Net.WebRequest]::Create($Url)
	
	
	try {
		$HttpResponse = $HttpRequest.GetResponse()
	}
	catch [Net.WebException] {
     $HttpResponse = $_.Exception.Response
     $HttpStatus = [int]$HttpResponse.StatusCode       
		
	}
	$HttpStatus = [int]$HttpResponse.StatusCode
	
	
switch ( $HttpStatus ) {
		
    101 {$Info ="[101: Switching Protocols] - "; Break}
    200 {$Info ="[200: Url is Active] - " ; Break }
    201 {$Info ="[201: Created] - " ; Break }
    202 {$Info ="[202: Accepted] - " ; Break }
	204 {$Info ="[204: No Content] - "; Break}
    301 {$Info ="[301: Moved Permanently] - " ; Break }
    302 {$Info ="[302: Found] - " ; Break }
    304 {$Info ="[304: Not Modified] - " ; Break }
	400 {$Info ="[400: Bad Request] - "; Break}
    401 {$Info ="[401: Unauthorized] - " ; Break }
    403 {$Info ="[403: Forbidden] - " ; Break }
    404 {$Info ="[404: Not Found] - " ; Break }
    405 {$Info ="[405: Method not Allowed] - "; Break}
    406 {$Info ="[406: Not Acceptable] - " ; Break }
    407 {$Info ="[407: Proxy Authentication Required] - " ; Break }
    415 {$Info ="[415: Unsupported Media Type] - " ; Break }
	422 {$Info ="[422: Unprocessable Entity] - "; Break}
    500 {$Info ="[500: Internal Server Error] - " ; Break }
    503 {$Info ="[503: Service Unavaiable] - " ; Break }
	504 {$Info ="[504: Gateway Timeout] - " ; Break }
    default {$Info = "[ "+$HttpStatus+" ] Cannot connect to: " ; Break }

}

$UrlInfo = $Info + " "  + $Url  	
return  $UrlInfo   
	
}


<#
Function name: UpdateReport
Description: Receives a data string as input and stores it in a report file    
Function calls: -
Input: $data
Output: -
#>


function UpdateReport( ) {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$data 
    )


    $ReportFileName = "PowerDecode_2020_Malware_Analysis_Temp_Report"
    $ReportOutFile =  [System.IO.Path]::GetTempPath() + $ReportFileName +".txt" 
    
    
    $Report = Get-Content $ReportOutFile  
    $Report += $data 
    $Report | Out-File $ReportOutFile 


return 

}


<#
Function name: ExtractShellcode
Description: Receives a script as input and checks if it contains shellcode   
Function calls: UpdateReport
Input: $Script
Output: -   
#>

function ExtractShellcode()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [string]$Script 
        )
      
      

#to lower conversion 

$lowerstring = $Script.toLower() 




$lowerstring = $lowerstring.replace(' ','').replace('0x','').replace(',',' ')


$pattern =  [regex] "\=[a-f|0-9|\s]{8,};"
$matches = $pattern.matches($lowerstring)
$shellcode = $matches.value
$shellcode= $shellcode.replace('=','').replace(';','')


$data = "Script attempted to inject shellcode into memory: " + "`r`n`r`n" + $shellcode
UpdateReport($data)  
    



return  

}

