##########################################
# Obfuscation Layer Recognizer Functions #
##########################################

function GetObfuscationType() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )
	
  if( IsCompressed $ObfuscatedScript ) {
      return "Compressed"
   }
    
  if( IsBase64 $ObfuscatedScript ) {   
      return "Base64"   
  }
  
  if( IsEncoded $ObfuscatedScript ) { 
      return "Encoded"  
  }
        
  if( IsStringBased $ObfuscatedScript ) {    
      return "String-Based"
  }

  else {  
      return "Unknown" 
  }

   
}


function IsCompressed() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string ]$InputString
    )
	
#to lower conversion 
$lowerstring = $InputString.toLower() 




$pattern = "io\.compression\.deflatestream"
$regex = [regex]::Match($lowerstring , $pattern)
$result = $regex.Success 


return $result


}


function IsEncoded() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )

$lowerstring = $ObfuscatedScript.toLower() 



#checking bxor
$pattern = [regex] "\-bxor"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     } 

#checking secure string
$pattern = [regex] "securestring"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }
#checking hex\oct\bin 
$pattern = [regex]  "\[convert\]\:\:toint16"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }


#remove spacelines 
$pattern = [regex]  " "
$matches = $pattern.Matches($lowerstring)

foreach  ($match in $matches) {

$ScriptNoSpacelines = $lowerstring.Replace( $match, '') 
}


#checking dec 
$pattern = [regex]  "\[int\]$_"
$matches = $pattern.Matches($ScriptNoSpacelines)
   if ($matches.Count -gt 0){
     return $true 
     }


return $false


}




function IsStringBased() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )



 $pattern = [regex] "(\{\d\}\'\s*-f)|(\'(.*?)\'\s*\+\s*\'(.*?)\')"
 $matches = $pattern.Matches($ObfuscatedScript) 

    if ($matches.Count -gt 0){
     return $true 
     }
     else {
      $lowerstring = ""
      ForEach ($char in $ObfuscatedScript ) {
       $lowerstring += $char.toLower()  
       }
        
    $pattern = [regex] "\[char\]\d" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
    $pattern = [regex] "\'righttoleft\'" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
     return $false
     }
}





function ExtractUrls() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$Script
    )
	
	
	
	
	$Urls = @()
	$Url = ""
	
	 
	
	$Pattern = [regex]  "(http[s]?|[s]?ftp[s]?)(:\/\/)(.*?)(\""|\'|\}|\@|\,|\s|\*|\?)"
	
	$Matches = $Pattern.matches($Script)
	
	Foreach($Group in $Matches.Groups) {
		if($Group.Name -eq 0) {
			$Url = $Group.Value
			$Url = $Url.SubString(0, $Url.Length - 1)
			$Urls += $Url
		}
	}
		
	
	return $Urls
}



function IsUrlActive() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$Url
    )
	
	$HTTP_Request = [System.Net.WebRequest]::Create($Url)
	try {
		$HTTP_Response = $HTTP_Request.GetResponse()
	}
	catch [Net.WebException] {
		return $False
	}
	$HTTP_Status = [int]$HTTP_Response.StatusCode
	
	if($HTTP_Status -eq 200) {
		return $True
	}
	else {
		return $False
	}
}



function UpdateReport( ) {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$data 
    )


    $ReportFileName = "PowerDecode_2020_Malware_Analysis_Temp_Report"
    $ReportOutFile =  [System.IO.Path]::GetTempPath() + $ReportFileName +".txt" 
    
    
    $Report = Get-Content $ReportOutFile  
    $Report += $data 
    $Report | Out-File $ReportOutFile 


return 

}


function ExtractShellcode()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [string]$String
        )
      
      

#to lower conversion 

$lowerstring = ""
ForEach ($char in $String ) {

$lowerstring += $char.toLower() 

}  



$lowerstring = $lowerstring.replace(' ','').replace('0x','').replace(',',' ')


$pattern =  [regex] "\=[a-f|0-9|\s]{8,};"
$matches = $pattern.matches($lowerstring)
$shellcode = $matches.value
$shellcode= $shellcode.replace('=','').replace(';','')


$data = "Script attempts to inject shellcode into memory: " + "`r`n`r`n" + $shellcode
UpdateReport($data)  
    



return  
    }

