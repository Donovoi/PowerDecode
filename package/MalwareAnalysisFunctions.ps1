<#
Function name: GetObfuscationType
Description: Determines the obfuscation type of the obfuscated script received as input 
Function calls: IsCompressed, IsBase64, IsStringBased, IsEncoded.
Input: $ObfuscatedScript 
Output: (a string representing the obfuscation type)
#>

function GetObfuscationType() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )
	
  if( IsCompressed $ObfuscatedScript ) {
      return "Compressed"
   }
    
  if( IsBase64 $ObfuscatedScript ) {   
      return "Base64"   
  }
  
   if( IsEncoded $ObfuscatedScript ) { 
      return "Encoded"  
  }
  
  if( IsStringBased $ObfuscatedScript ) {    
      return "String-Based"
  }
        
 
  else {  
      return "Unknown" 
  }

   
}

<#
Function name: IsCompressed
Description: Returns true if the obfuscation type is compressed 
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false  
#>
function IsCompressed() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string ]$ObfuscatedScript
    )
	
#to lower conversion 
$lowerstring = $ObfuscatedScript.toLower() 




$DeflatePattern = [regex] "io\.compression\.deflatestream"
$GzipPattern = [regex] "io\.compression\.gzipstream"

$DeflateMatches = $DeflatePattern.matches($lowerstring)
$GzipMatches = $GzipPattern.matches($lowerstring)


if ($DeflateMatches.Count -gt 0){
     return $true 
     }
	 
if ($GzipMatches.Count -gt 0){
     return $true 
     } 


return $false 


}

<#
Function name: IsEncoded
Description: Returns true if the obfuscation type is encoded
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false   
#>
function IsEncoded() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )

$lowerstring = $ObfuscatedScript.toLower() 



#checking bxor
$pattern = [regex] "\-bxor"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     } 

#checking secure string
$pattern = [regex] "securestring"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }
#checking hex\oct\bin 
$pattern = [regex]  "\[convert\]\:\:toint16"
$matches = $pattern.Matches($lowerstring)
   if ($matches.Count -gt 0){
     return $true 
     }


#remove spacelines 
$pattern = [regex]  " "
$matches = $pattern.Matches($lowerstring)

foreach  ($match in $matches) {

$ScriptNoSpacelines = $lowerstring.Replace( $match, '') 
}


#checking dec 
$pattern = [regex]  "\[int\]$_"
$matches = $pattern.Matches($ScriptNoSpacelines)
   if ($matches.Count -gt 0){
     return $true 
     }


return $false


}


<#
Function name: IsStringBased
Description: Returns true if the obfuscation type is string-based
Function calls: -
Input: $ObfuscatedScript
Output: $true/$false
#>

function IsStringBased() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$ObfuscatedScript
    )



 $pattern = [regex] "(\{\d\}\'\s*-f)|(\'(.*?)\'\s*\+\s*\'(.*?)\')"
 $matches = $pattern.Matches($ObfuscatedScript) 

    if ($matches.Count -gt 0){
     return $true 
     }
     else {
      $lowerstring = $ObfuscatedScript.toLower() 
    
        
    $pattern = [regex] "\[char\]\d" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
    $pattern = [regex] "\'righttoleft\'" 
    $matches = $pattern.Matches($lowerstring) 


     if ($matches.Count -gt 0){
     return $true 
     }
     
     
     
     
     return $false
     }
}



<#
Function name: ExtractUrls
Description: Receives a script as input and returns an array containing all urls detected  
Function calls: -
Input: $Script
Output: $Urls  
#>

function ExtractUrls() {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$Script
    )
	
	
	
	
	$Urls = @()
	$Url = ""
	
	 
	
	$Pattern = [regex]  "(http[s]?|[s]?ftp[s]?)(:\/\/)(.*?)(\""|\'|\}|\@|\,|\s|\*|\?)"
	
	$Matches = $Pattern.matches($Script)
	
	Foreach($Group in $Matches.Groups) {
		if($Group.Name -eq 0) {
			$Url = $Group.Value
			$Url = $Url.SubString(0, $Url.Length - 1)
			$Urls += $Url
		}
	}
		
	
	return $Urls
}

<#
Function name: UrlHttpResponseCheck
Description: Receives a url as input and returns the associated http response status code  
Function calls: ConvertHexStringToByteArray UpdateReport
Input: $Url
Output: $UrlInfo 
#>

function UrlHttpResponseCheck() {
	param([Parameter(Mandatory = $True)] [string]$Url
    )
	
	$HttpRequest = [System.Net.WebRequest]::Create($Url)
	
	
	try {
		$HttpResponse = $HttpRequest.GetResponse()
	}
	catch [Net.WebException] {
     $HttpResponse = $_.Exception.Response
     $HttpStatus = [int]$HttpResponse.StatusCode       
		
	}
	$HttpStatus = [int]$HttpResponse.StatusCode
	
	
switch ( $HttpStatus ) {
		
    101 {$Info ="[101: Switching Protocols] - "; Break}
    200 {$Info ="[200: Url is Active] - " ; Break }
    201 {$Info ="[201: Created] - " ; Break }
    202 {$Info ="[202: Accepted] - " ; Break }
	204 {$Info ="[204: No Content] - "; Break}
    301 {$Info ="[301: Moved Permanently] - " ; Break }
    302 {$Info ="[302: Found] - " ; Break }
    304 {$Info ="[304: Not Modified] - " ; Break }
	400 {$Info ="[400: Bad Request] - "; Break}
    401 {$Info ="[401: Unauthorized] - " ; Break }
    403 {$Info ="[403: Forbidden] - " ; Break }
    404 {$Info ="[404: Not Found] - " ; Break }
    405 {$Info ="[405: Method not Allowed] - "; Break}
    406 {$Info ="[406: Not Acceptable] - " ; Break }
    407 {$Info ="[407: Proxy Authentication Required] - " ; Break }
    415 {$Info ="[415: Unsupported Media Type] - " ; Break }
	422 {$Info ="[422: Unprocessable Entity] - "; Break}
    500 {$Info ="[500: Internal Server Error] - " ; Break }
    503 {$Info ="[503: Service Unavaiable] - " ; Break }
	504 {$Info ="[504: Gateway Timeout] - " ; Break }
    default {$Info = "[ "+$HttpStatus+" ] Cannot connect to: " ; Break }

}

$UrlInfo = $Info + " "  + $Url  	
return  $UrlInfo   
	
}


<#
Function name: UpdateReport
Description: Receives a data string as input and stores it in a report file    
Function calls: -
Input: $data
Output: -
#>


function UpdateReport( ) {
	param(
        [Parameter(
			Mandatory = $True)]
        [string]$data 
    )


    $ReportFileName = "PowerDecode_2020_Malware_Analysis_Temp_Report"
    $ReportOutFile =  [System.IO.Path]::GetTempPath() + $ReportFileName +".txt" 
    
    
    $Report = Get-Content $ReportOutFile  
    $Report += $data 
    $Report | Out-File $ReportOutFile 


return 

}


<#
Function name: ExtractShellcode
Description: Checks and exstract shellcode from input script   
Function calls: ConvertHexStringToByteArray
Input:  $Script
Output: $data   
#>

function ExtractShellcode()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [string]$Script 
        )
      
      
$data = ""

#hex format shellcode check  

$pattern = [regex]  "(0x[0-9a-z]\,){1,1}"
$matches = $pattern.matches($Script)

foreach ($match in $matches){
  $byte = $match.value.replace('0x', '' )
  $Script = $Script.replace(  $match.value ,"0x0"+$byte   )
}

$lowerstring = ($Script.toLower()) |Out-String
$lowerstring = $lowerstring.replace('0x','').replace(',',' ')

$pattern =  [regex] "\=[a-f0-9\s]{8,}(\;){0,1}"
$matches = $pattern.matches($lowerstring)
if ($matches.count -gt 0) {
 $shellcode = $matches[0].value
 $shellcode= $shellcode.replace('=','').replace(';','')
 $HexString = $shellcode.replace(' ', '')
 
 [byte[]] $bytes = ConvertHexStringToByteArray $HexString 
 $assembly = Format-Hex -InputObject $bytes
 

 $data = "Script attempts to inject shellcode into memory: " + "`r`n`r`n" + $assembly
 $data += "`r`n" +"PowerDecode analysis ends here, please analyze this code on a debugger to get more information:"+ "`r`n`r`n"
 $data += "Input for ODA (https://onlinedisassembler.com/odaweb/):"+"`r`n"+$shellcode+ "`r`n"
 $data += "`r`n"+"Input for SCDBG (http://sandsprite.com/blogs/index.php?uid=7&pid=152):"+"`r`n"+$HexString+ "`r`n"

  
  
}

#Base64 shellcode check
$regex =@"
\[[Bb][Yy][Tt][Ee]\[\]\][\$](.*?)\= \[System\.Convert\]\:\:FromBase64String\(["']{1,1}([A-Za-z0-9\+\/]{5,})[\=]{1,2}
"@

$pattern = [regex] $regex
$matches = $pattern.matches($Script)


if ($matches.count -gt 0) {

$shellcode = $matches[0].value

$regex =@"
\[[Bb][Yy][Tt][Ee]\[\]\][\$](.*?)\= \[System\.Convert\]\:\:FromBase64String\(["']{1,1}
"@

$pattern = [regex] $regex
$matches = $pattern.matches($shellcode)

$junkdata = $matches[0].value
$shellcode= $shellcode.replace($junkdata ,"")

[Byte[]] $bytes = [System.Convert]::FromBase64String($shellcode)

$assembly = Format-Hex -InputObject $bytes

$HexString = ($bytes|ForEach-Object ToString X2) -join ' '

$data += "Shellcode was base64 encoded " + "`r`n`r`n" + $assembly

$data = "Script contains base64 encoded shellcode: " + "`r`n`r`n" + $assembly
$data += "`r`n`r`n" +"PowerDecode analysis ends here, please analyze this code on a debugger to get more information:"+ "`r`n`r`n"
$data += "Input for ODA (https://onlinedisassembler.com/odaweb/):"+"`r`n"+$HexString+ "`r`n"
$data += "`r`n"+"Input for SCDBG (http://sandsprite.com/blogs/index.php?uid=7&pid=152):"+"`r`n"+$HexString.replace(' ','')+ "`r`n"


    
}

return  $data 


}

<#
Function name: ConvertHexStringToByteArray
Description: Takes an array of hexadecimals and returns an array containing those values converted into bytes
Function calls: -
Input: $String
Output: $bytes
#>

function ConvertHexStringToByteArray
{

[CmdletBinding()]
Param ( [Parameter(Mandatory = $True, ValueFromPipeline = $True)] [String] $String )


if ($String.Length -eq 0) { 
return 
}
 
if ($String.Length -eq 1) { 
[byte[]] $bytes = ([System.Convert]::ToByte($String,16)) 
return $bytes 
}

if (($String.Length % 2 -eq 0) -and ($String.IndexOf(":") -eq -1)) { 
[byte[]] $bytes = $String -split '([a-f0-9]{2})' | foreach-object { if ($_) {[System.Convert]::ToByte($_,16)}} 
return $bytes 
}
else{
      if ($String.IndexOf(":") -ne -1){ 
      [byte[]] $bytes = $String -split ':+' | foreach-object {[System.Convert]::ToByte($_,16)} 
      return $bytes 
	  }
}

}


<#
Function name: GetVariablesContent
Description: Takes a script as input and returns a list containing the variables declared by the same (name-value) 
Function calls: EncodeBase64
Input: $Script
Output: $Variables
#>


function GetVariablesContent()  {
        param(
            [Parameter( 
                Mandatory=$True, 
                Valuefrompipeline = $True)]
            [string]$Script 
        )

$Declarations = ""
foreach ($row in $Script.split(';')) {
 if (($row -match "$") -and  ($row -match '=')   ) { 
   $Declarations += $row + " ;"

 }
}



$GetUDVariables = get-content package\GetUDvariables.txt
$Arguments = $Declarations+"`r`n"+$GetUDvariables

$B64Arguments = EncodeBase64 $Arguments
$B64Arguments = "powershell -encodedcommand " + $B64Arguments


$TempFile = [System.IO.Path]::GetTempPath() + [GUID]::NewGuid().ToString()+"GVC"+ ".ps1"; 
            
$B64Arguments | Out-File $TempFile


$ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo
$ProcessInfo.FileName = "powershell"
$ProcessInfo.CreateNoWindow = $true
$ProcessInfo.RedirectStandardError = $false
$ProcessInfo.RedirectStandardOutput = $true
$ProcessInfo.UseShellExecute = $false
$ProcessInfo.Arguments = "-File $($TempFile)"
$Process = New-Object System.Diagnostics.Process
$Process.StartInfo = $ProcessInfo
$Process.Start() | Out-Null
$Variables = $Process.StandardOutput.ReadToEnd()
Stop-Process $Process
Remove-Item $TempFile

if ($Variables -match "ParserError") {
	return ""
}

return $Variables

}
